<!DOCTYPE html>
<html>

<head>
    <title>OpenSeadragon Canvas Overlay Demo</title>
    <script src="openseadragon/openseadragon.js"></script>
    <script src="openseadragon-threejs-overlay.js"></script>
    <script src="js/openseadragon-viewerinputhook.js"></script>
    <script src="js/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/sketch-js@1.1.3/js/sketch.js"></script> -->
    <script src="js/stats.min.js"></script>


    <script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
    <style type="text/css">
        html,
        body,
        .openseadragon1 {
            width: 100%;
            height: 100%;
            margin: 0;
        }
    </style>
    <script>

        // ----------
        App = {
            // ----------
            init: function () {
                var self = this;

                var tileSource = {
                    Image: {
                        xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                        Url: "http://openseadragon.github.io/example-images/highsmith/highsmith_files/",
                        Format: "jpg",
                        Overlap: "2",
                        TileSize: "256",
                        Size: {
                            Height: "9221",
                            Width: "7026"
                        }
                    }
                };

                this.viewer = OpenSeadragon({
                    id: "contentDiv",
                    // debugMode: true,
                    gestureSettingsMouse: { clickToZoom: false, dblClickToZoom: false },
                    prefixUrl: "openseadragon/images/",
                    tileSources: [{
                        tileSource: tileSource,
                        width: 2,
                        y: 0,
                        x: 0
                    }]
                });

                var overlay = this.viewer.threejsOverlay();
                console.log(overlay);
                var stats, camera, scene, geometry, material, index = 0, mesh, renderer = new THREE.WebGLRenderer(overlay.context3d());
                var vec = new THREE.Vector3(); // create once and reuse
                var pos = new THREE.Vector3(); // create once and reuse

                setup();
                animate();

                // var viewerInputHook = viewer.addViewerInputHook({ hooks: [...] });
                var viewerInputHook = this.viewer.addViewerInputHook({
                    hooks: [
                        // { tracker: 'viewer', handler: 'moveHandler', hookHandler: onHookOsdViewerMove },
                        // { tracker: 'viewer', handler: 'scrollHandler', hookHandler: onHookOsdViewerScroll },
                        // { tracker: 'viewer', handler: 'clickHandler', hookHandler: onHookOsdViewerClick }
                    ]
                });

                function onHookOsdViewerClick(event) {
                    let touch = { x: Math.round(event.position.x), y: Math.round(event.position.y) };

                    console.log(touch.x, touch.y);
                    vec.set(
                        (touch.x / window.innerWidth) * 2 - 1,
                        - (touch.y / window.innerHeight) * 2 + 1,
                        0.5);
                    // camera.updateProjectionMatrix();
                    console.log(distance, camera, vec);
                    vec.unproject(camera);

                    vec.sub(camera.position).normalize();

                    var distance = - camera.position.z / vec.z;
                    pos.copy(camera.position).add(vec.multiplyScalar(distance));
                    console.log(pos);
                    var positions = mesh.geometry.attributes.position.array;

                    positions[index++] = pos.x;
                    positions[index++] = pos.y;
                    positions[index++] = 0;

                    mesh.geometry.setDrawRange(0, index / 3);

                    mesh.geometry.attributes.position.needsUpdate = true; // required after the first render
                }

                $(window).resize(function () {
                    overlay.resize();
                });

                function setup() {
                    let MAX_POINTS = 500000;
                    // console.log(self.viewer);
                    let width = self.viewer.container.clientWidth;
                    let height = self.viewer.container.clientHeight;
                    console.log(width, height);
                    camera = new THREE.PerspectiveCamera(75, width / height, 1, 10000);
                    camera.position.x = 1000;
                    camera.position.y = 600;
                    camera.position.z = 2000;
                    // scene
                    scene = new THREE.Scene();

                    var triangles = 1000000;

                    var geometry = new THREE.BufferGeometry();

                    var positions = [];
                    var normals = [];
                    var colors = [];

                    var color = new THREE.Color();

                    var n = 800, n2 = n / 2;	// triangles spread in the cube
                    var d = 120, d2 = d / 2;	// individual triangle size

                    var pA = new THREE.Vector3();
                    var pB = new THREE.Vector3();
                    var pC = new THREE.Vector3();

                    var cb = new THREE.Vector3();
                    var ab = new THREE.Vector3();

                    for (var i = 0; i < triangles; i++) {

                        // positions

                        var x = Math.random() * n - n2;
                        var y = Math.random() * n - n2;
                        var z = Math.random() * n - n2;

                        var ax = x + Math.random() * d - d2;
                        var ay = y + Math.random() * d - d2;
                        var az = z + Math.random() * d - d2;

                        var bx = x + Math.random() * d - d2;
                        var by = y + Math.random() * d - d2;
                        var bz = z + Math.random() * d - d2;

                        var cx = x + Math.random() * d - d2;
                        var cy = y + Math.random() * d - d2;
                        var cz = z + Math.random() * d - d2;

                        positions.push(ax, ay, 0);
                        positions.push(bx, by, 0);
                        positions.push(cx, cy, 0);

                        // flat face normals

                        pA.set(ax, ay, az);
                        pB.set(bx, by, bz);
                        pC.set(cx, cy, cz);

                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);

                        cb.normalize();

                        var nx = cb.x;
                        var ny = cb.y;
                        var nz = cb.z;

                        normals.push(nx, ny, nz);
                        normals.push(nx, ny, nz);
                        normals.push(nx, ny, nz);

                        // colors

                        var vx = (x / n) + 0.5;
                        var vy = (y / n) + 0.5;
                        var vz = (z / n) + 0.5;

                        color.setRGB(vx, vy, vz);

                        colors.push(color.r, color.g, color.b);
                        colors.push(color.r, color.g, color.b);
                        colors.push(color.r, color.g, color.b);

                    }

                    function disposeArray() { this.array = null; }

                    geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3).onUpload(disposeArray));
                    geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3).onUpload(disposeArray));
                    geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3).onUpload(disposeArray));

                    geometry.computeBoundingSphere();

                    // var material = new THREE.MeshPhongMaterial({
                    // 	color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
                    // 	side: THREE.DoubleSide, vertexColors: THREE.VertexColors
                    // });
                    var material = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });

                    mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);

                    //

                    // renderer = new THREE.WebGLRenderer();
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    renderer.gammaInput = true;
                    renderer.gammaOutput = true;

                    stats = new Stats();
                    stats.dom.style.left = 'unset';
                    stats.dom.style.right = '0px';
                    document.body.appendChild(stats.dom)

                }

                function animate() {
                    requestAnimationFrame(animate);
                    stats.update();
                    renderer.render(scene, camera);
                }
            }
        };

        // ----------
        $(document).ready(function () {
            App.init();

        });

    </script>
</head>

<body>
    <div id="contentDiv" class="openseadragon1"></div>
</body>

</html>